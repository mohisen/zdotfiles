# -*- coding: utf-8 -*-

#########################################################################
## This scaffolding model makes your app work on Google App Engine too
## File is released under public domain and you can use without limitations
#########################################################################

## if SSL/HTTPS is properly configured and you want all HTTP requests to
## be redirected to HTTPS, uncomment the line below:
# request.requires_https()

if not request.env.web2py_runtime_gae:
    ## if NOT running on Google App Engine use SQLite or other DB
    db = DAL('sqlite://storage.sqlite',pool_size=1,check_reserved=['all'])
else:
    ## connect to Google BigTable (optional 'google:datastore://namespace')
    db = DAL('google:datastore+ndb')
    ## store sessions and tickets there
    session.connect(request, response, db=db)
    ## or store session in Memcache, Redis, etc.
    ## from gluon.contrib.memdb import MEMDB
    ## from google.appengine.api.memcache import Client
    ## session.connect(request, response, db = MEMDB(Client()))

## by default give a view/generic.extension to all actions from localhost
## none otherwise. a pattern can be 'controller/function.extension'
response.generic_patterns = ['*'] if request.is_local else []

## (optional) optimize handling of static files
# response.optimize_css = 'concat,minify,inline'
# response.optimize_js = 'concat,minify,inline'
## (optional) static assets folder versioning
# response.static_version = '0.0.0'
#########################################################################
## Here is sample code if you need for
## - email capabilities
## - authentication (registration, login, logout, ... )
## - authorization (role based authorization)
## - services (xml, csv, json, xmlrpc, jsonrpc, amf, rss)
## - old style crud actions
## (more options discussed in gluon/tools.py)
#########################################################################

from gluon.tools import Auth, Service, PluginManager
import random
import itertools

auth = Auth(db)
service = Service()
plugins = PluginManager()

# before define_tables()
auth.settings.extra_fields['auth_user'] = [
    Field('username', unique=True),
    Field('name', required=IS_NOT_EMPTY())
    ]

## create all tables needed by auth if not custom tables
auth.define_tables(username=False, signature=False)

## configure email
mail = auth.settings.mailer
mail.settings.server = 'logging' if request.is_local else 'smtp.gmail.com:587'
mail.settings.sender = 'tazjel@gmail.com'
mail.settings.login = 'tazjel@gmail.com:WQazzaq1'

## configure auth policy
auth.settings.registration_requires_verification = False
auth.settings.registration_requires_approval = False
auth.settings.reset_password_requires_verification = True

## if you need to use OpenID, Facebook, MySpace, Twitter, Linkedin, etc.
## register with janrain.com, write your domain:api_key in private/janrain.key
from gluon.contrib.login_methods.janrain_account import use_janrain
use_janrain(auth, filename='private/janrain.key')

#########################################################################
## Define your tables below (or better in another model file) for example
##
## >>> db.define_table('mytable',Field('myfield','string'))
##
## Fields can be 'string','text','password','integer','double','boolean'
##       'date','time','datetime','blob','upload', 'reference TABLENAME'
## There is an implicit 'id integer autoincrement' field
## Consult manual for more options, validators, etc.
##
## More API examples for controllers:
##
## >>> db.mytable.insert(myfield='value')
## >>> rows=db(db.mytable.myfield=='value').select(db.mytable.ALL)
## >>> for row in rows: print row.id, row.myfield
#########################################################################

## after defining tables, uncomment below to enable auditing
# auth.enable_record_versioning(db)

db.auth_user.first_name.readable = db.auth_user.first_name.writable = False
db.auth_user.last_name.readable = db.auth_user.last_name.writable = False
auth.settings.login_next = URL("game","current")
auth.settings.logout_next = URL("default","login")
auth.settings.login_url = URL("default", "login")

db.define_table('game_status',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('player_status',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('player_type',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('game',
    Field('name', default='Default Game', required=IS_NOT_EMPTY()),
    Field('description', 'text', default=''),
    Field('status_id', 'reference game_status', notnull=True)
    )
# Field('teamate_id', 'reference player'),
# Field('other_teamate_id', 'reference player'),


db.define_table('teams',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description'),
# 	Field('players', 'reference player'),
    )

db.define_table('player',
    Field('game_id', 'reference game', notnull=True),
    Field('user_id', 'reference auth_user', notnull=True),
    Field('target_id', 'reference player'),
    Field('status_id', 'reference player_status', notnull=True),
    Field('role_id', 'reference player_type', notnull=True)
    )

from gluon import current
current.db = db

db.game_status.update_or_insert(id = 1, name = 'not started')
db.game_status.update_or_insert(id = 2, name = 'started')
db.game_status.update_or_insert(id = 3, name = 'finished')
db.game_status.update_or_insert(id = 4, name = 'deal')
db.game_status.update_or_insert(id = 5, name = 'first')

db.game_status.update_or_insert(id = 6, name = 'sun')
db.game_status.update_or_insert(id = 7, name = 'trump')

db.game_status.update_or_insert(id = 8, name = 'trump_2_open')

db.game_status.update_or_insert(id = 9, name = 'trump_2_close')


db.game_status.update_or_insert(id = 10, name = 'trump_3_open')

db.game_status.update_or_insert(id = 11, name = 'trump_3_close')

db.game_status.update_or_insert(id = 12, name = 'trump_4_open')

db.game_status.update_or_insert(id = 13, name = 'trump_4_close')

db.game_status.update_or_insert(id = 14, name = 'trump_5_open')

db.game_status.update_or_insert(id = 15, name = 'sun_2')

db.game_status.update_or_insert(id = 16, name = 'casho')

# player status

db.player_status.update_or_insert(id = 1, name = 'alive')
db.player_status.update_or_insert(id = 2, name = 'dead')

db.player_status.update_or_insert(id = 3, name = 'dealer_1')
db.player_status.update_or_insert(id = 4, name = 'dealer_2')
db.player_status.update_or_insert(id = 5, name = 'dealer_other_1')
db.player_status.update_or_insert(id = 6, name = 'dealer_other_2')

# player type

db.player_type.update_or_insert(id = 1, name = 'host')
db.player_type.update_or_insert(id = 2, name = 'player')
db.player_type.update_or_insert(id = 3, name = 'banned', description = 'A player that is no longer allowed to join this game')
db.player_type.update_or_insert(id = 4, name = 'gone', description = 'A player that has left the game after it has started')
db.player_type.update_or_insert(id = 5, name = 'watching', description = 'A player that is no longer allowed to join this game')
db.player_type.update_or_insert(id = 6, name = 'reserve', description = 'A player that is no longer allowed to join this game')

########################

order_classic = [11, 10, 14, 13, 12, 9, 8, 7]
order_trump = [12, 9, 11, 10, 14, 13, 8, 7]

value_classic = [11, 10, 4, 3, 2, 0, 0, 0]
value_trump = [20, 14, 11, 10, 4, 3, 0, 0]

db.define_table('deck',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )
db.define_table('classic',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description'),
	Field('order'),
	Field('value'),
    )
db.define_table('rewards',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description'),
	Field('order'),
	Field('value'),
    )


db.define_table('peer_rating',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description'),
	Field('order'),
	Field('value'),
    )

db.define_table('cards',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description'),
	Field('cards_value'),
	Field('color'),
	Field('trump'),
    )
# db.cards.update_or_insert(id = 0, name = 'gone', description = 'A player that has left the game after it has started')

db.define_table('state_now',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('loot',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('cards_order_',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('deal',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('cards_values',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('auction',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('auction_history',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('contract',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )

db.define_table('bonus_value_team_1',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('bonus_value_team_2',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('check_for_belote',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


db.define_table('check_for_con',
    Field('name', required=IS_NOT_EMPTY()),
    Field('description')
    )


from card import Card
cards = [Card(c[0], c[1]) for c in itertools.product(range(7, 15), ['Heart', 'Diamond', 'Spade', 'Club'])]




#     def __init__(self):
#         deck = [Card(c[0], c[1]) for c in itertools.product(range(7, 15), ['Heart', 'Diamond', 'Spade', 'Club'])]


def shuffle():
	random.shuffle(deck)

def display_deck():
	display = "Display Deck"

def set_trump(card_color):
	for card in deck:
		if card.color == card_color:
			card.trump = True
		else:
			ard.trump = False




# loot_team_1 = []
# bonus_value_team_1 = 0
# loot_team_2 = []
# bonus_value_team_2 = 0
# players_list = [player_1, player_2, player_3, player_4]

# deal(player_1, player_2, player_3, player_4, deck)

# contract_value, trump, contracting_team = launch_auction()

# set_trump(deck, trump)
# deal(player_1, player_2, player_3, player_4, deck)
# check_for_belote(player_1, player_2, player_3, player_4)

# قاطع أو ػاطع: تعني اللاعب الذي يلعب ورقة مخالفة للأوراق الموجودة على الأرض، فيُقال علي سبيل المثال قاطع سبيت أي أن اللاعب رمى ورقة السبيت واللعب أساساً كان في غير السبيت.
# حلْ الإكه: تعني اللاعب الذي يبدأ اللعب في الصن بورقة الإكه وهي أكبر الأوراق قيمةً في الصن، وهي طريقة لضمان أن لا تكون جميع الأوراق للفريق الآخر فيحصلوا على النقاط الكاملة.
# عملية التربيع: وتعني اللاعب الذي يبدأ برمي ورقة الحكم، فيُقال ربّع فلان أي بدأ بورقة الحكم، وعملية التربيع ممنوعة في الدبل والدبل فور.
# التكويش أو التخييش: وهي العملية التي يحصل فيها أحد الفريقين على نقاط اللعبة إما بسبب محاولة غش الفريق الآخر أو خرق القوانين.
# الصكة أو الطقة: هي الدورة الواحدة التي يقوم اللاعبين برمي جميع الأوراق الـ 32.
# دِسَمْ: وهي أن يرمي اللاعب أكبر الأوراق قيمةً إذا كانت الأوراق التي في الأرض لصالح زميله في اللعب.
# التهريب: هي عملية ذكية يقوم فيها اللاعب برمي الورقة التي لا يحتاجها، لكي يفهم زميله أنه يريد أوراق غير التي رماها.
# تفرنك: عندما يملك اللاعب أوراقاً قوية في "زات" أو نوع معين من الأوراق (مثال العشرة والباش والميم) ولا يملك الورقة الأكبر وهي الإكه، فيرمي اللاعب ورقة قليلة القيمة كضحية من أجل أن يأكلها أحد اللاعبين الذي يملك ورقة الإكه، وينفرد هو بالزات.
# كبوت: هي العملية التي يحصل فيها أحد الفريقين على جميع الأوراق في "صكة" واحدة.








#

def compare_cards_is_bigger(card_1, card_2):
	if card_1.trump == card_2.trump:
		if card_1.trump:
			return order_trump.index(card_1.value) < order_trump.index(card_2.value)
		else:
			if card_1.color == card_2.color:
				return order_classic.index(card_1.value) < order_classic.index(card_2.value)
			else:
				return True
	else:
		return card_1.trump

print(" ------- Game On -------")

def game_on():
	for i in range(1, 9):
		state = []
		add_card_to_state(player_1)
		add_card_to_state(player_2)
		add_card_to_state(player_3)
		add_card_to_state(player_4)

#             print("---------- state " + str(i) + "  ----------")
#             self.display_state()
